\section{Implementierung}
%TODO: sec:ansatz
Für die Implementierung des in Abschnitt \ref{sec:ansatz} vorgeschlagenen Lösungsansatzes, wurde eine möglichst flexible Struktur des Programmes verwendet. Wie in Abschnitt \ref{sec:c++} begründet, wurde
als Implementationssprache C++ gewählt. Durch den Einsatz von C++ kann ein einfach erweiterbares Programmgerüst geschrieben werden, welches es erlaubt, schnell und ohne großen Aufwand mehrere Nachbarschaften
für die VNS zu implementieren. 

Um diese flexible Struktur zu ermöglichen wurde das Programm in vier unabhängige Bereiche aufgeteilt, welche durch eine einzelne Startroutine zusammengehalten werden. Diese Bereiche können grob als Parser, 
Konstruktionsheuristik, Variable Nachbarschaftssuche, und Nachbarschaften zusammengefasst werden. Hinzu kommt die sogenannte Solution, eine eigene Klasse um eine Lösung sowohl zu speichern, aber auch um Möglichkeiten
anzubieten, eine bestehende Lösung zu verändern. Diese einzelnen Bereiche sollen im folgenden Abschnitt ausführlich besprochen werden.

\subsection{Solution}
Bei Solution handelt es sich um die Basisklasse für alle weiteren Operationen. Sie speichert sowohl den Graphen, von dem bei der Lösung ausgegangen wird, als auch die Lösung selbst, mit konkret verteilten Farben
für einzelne Partitionen. Außerdem stellt Solution Methoden bereit, um Veränderungen an Lösungen vorzunehmen, wie sie etwa von den Nachbarschaften gebraucht werden, um einzelne Knoten umzufärben, oder zu ersetzen.
Außerdem besitzt Solution mehrere Methoden, einen Problemgraphen aus einer Datei auszulesen, und diesen wiederum in einem Solution-Objekt zu speichern. Diese Methoden zum Einlesen von Dateien werden genauer 
in Abschnitt \ref{sec:parser} besprochen.

\singlespacing
\lstset{style=customc}
\begin{lstlisting}[caption={Signatur der Solutionklasse},label=lst:solution]
class Solution {
   public:
      Solution();
      Solution(Solution *s);
      ~Solution();
      
      void requestDeepCopy();

      Graph *g;
      int numParts;
      int *partition;
      std::vector<Vertex> *partNodes;
      int colorsUsed;
      int *representatives;
      int *copyCounter;
      
      int getPartition(Vertex v);
      unsigned int getOriginalId(Vertex v);
      int getPartitionColor(Vertex v);
      int getColorDegree(Vertex v);
      
      int minPossibleColor(Vertex v);
      boost::tuple<int, int> getColorDegreeAndMinColor(Vertex v);
      bool isPartitionColored(Vertex v);
      
      void setOriginalId(Vertex v, int id);
      void setPartitionColor(Vertex v, int color);
      
      void print(std::ostream& out);
      std::string toString();
      
      static Solution* fromColStream(std::istream& in);
      static Solution* fromColBStream(std::istream& in);
      static Solution* fromPcpStream(std::istream& in);
      
      void addVertex(int part, Vertex id);
      void removeVertex(Vertex id);
      void addEdge(Vertex v1, Vertex v2);
      void replaceVertex(Vertex toR, Vertex rep, Solution& full);
      
      #ifdef ubigraph
      void redraw();
      void redraw(int shift);
      void prepareUbigraph();
      #endif
      
   private:
      boost::property_map<Graph, boost::vertex_index1_t>::type partitionMap;
      boost::property_map<Graph, boost::vertex_index2_t>::type idMap;
};
\end{lstlisting}
\setstretch{1.5}

Besonders interessant bei der Solution-Klasse ist die automatisch bereitgestellte Kopiermechanik. Einer der besonderen Eigenschaften von C++ ist es, für jede Klasse automatisch einen sogenannten Kopierkonstruktor
bereitzustellen, welcher als Parameter ein Objekt des selben Types entgegennimmt, und dieses kopiert. Da im Falle einer Lösung aber nicht immer alle Daten kopiert werden müssen, wurde in dieser Arbeit eine
eigene Kopiermechanik implementiert. Wie in Listing \ref{lst:copy} zu sehen ist, wird ein Großteil der Referenzdatentypen kopiert, da diese häufig garnicht verändert werden. 

Das Kopieren einer Lösung kommt vor Allem bei den verschieden Nachbarschaften zum Einsatz. Eine bestehende Lösung soll verändert werden, ohne, dass die Information der Ausgangslösung verloren geht. Also wird
die bestehende Lösung kopiert, und die Veränderungen nur auf der neuen Lösung ausgeführt. Da viele der Nachbarschaften darauf basieren, dass ausschließlich die Lösungsfarben verändert werden, kann zum Beispiel, 
anstatt den gesamten Graphen zu kopieren, eine Referenz auf den alten Graphen aufrecht erhalten werden. Selbiges gilt natürlich auch für alle direkt mit dem Graph in Verbindung stehenden Datenspeichern. 

\singlespacing
\begin{lstlisting}[caption={Der Kopierkonstruktor der Solutionklasse},label={lst:copy}]
Solution::Solution(Solution *toCopy) {
   this->partNodes = NULL;
   this->g = toCopy->g;
   this->representatives = toCopy->representatives;
   this->copyCounter = toCopy->copyCounter;
   *this->copyCounter += 1;
   this->partitionMap = get(vertex_index1_t(), *this->g);
   this->idMap = get(vertex_index2_t(), *this->g);   
   
   this->numParts = toCopy->numParts;
   this->colorsUsed = toCopy->colorsUsed;

   
   this->partition = new int[this->numParts];
   for (int i = 0; i < this->numParts; i++) {
      this->partition[i] = toCopy->partition[i];
   }
}
\end{lstlisting}
\setstretch{1.5}

Nun könnten aber Probleme entstehen. Zum einen, wenn eine Nachbarschaft beispielsweise Knoten aus dem zu Grunde liegenden Graphen austauscht, um eine bessere Lösung zu erhalten. Da durch das unechte Kopieren
der in einem Solutionobjekt referenzierte Graph auch bei anderen Lösungen zum Einsatz kommt, würde eine Veränderung auf einem Graphen, zu Veränderungen und aller Wahrscheinlichkeit nach zu Fehlern in alternativen
Lösungen führen, welche dann unweigerlich unzulässige Ergebnisse zur Folge hätten. Daher kann mit der Methode \texttt{requestDeepCopy} eine vollständige Kopie des Solutionobjektes angefordert werden. In dieser
Methode werden dann alle verbleibenden Fremdreferenzen nocheinmal kopiert, und in eigens für das anfragende Solutionobjekt reservierte Speicherbereiche geschrieben.

Ein anderes Problem entsteht beim Aufräumen von Objekten. Sollte durch das Löschen eines Solutionobjektes auch dessen referenzierter Graph verschwinden, würde das zu Speicherfehlern bei anderen Objekten führen, 
welche auf den selben Graphen zeigen. Daher wurde der Destruktor, welcher zum Aufräumen eines Objektes aufgerufen wird, überschrieben, und löscht nun nur noch referenzierte Objekte, wenn kein anderes Objekt
mehr Referenzen auf das selbe Objekt hält. Um dies zu ermöglichen wird von allen Solutionobjekten, welche auf den selben Graphen referenzieren ein Counter referenziert, welcher die Anzahl der
Verweise auf den selben Graphen mitzählt. So lange dieser Zähler über eins ist, wird kein Objekt gelöscht. Wird nun der Destruktor eines Solutionobjektes aufgerufen, überprüft dieser, ob er die letzte
Referenz auf diese Objekte hält. Wenn ja, löscht er diese und seine eigenen Referenzen, wenn nicht, löscht er wiederum nur seine eigenen Referenzen und vermindert den Zähler um eins.

\subsubsection{StoredSolution}
Um eine einzelne Lösung von einer anderen zu unterscheiden, sind zwei Informationen notwendig: die Auswahl der Repräsentanten, und die Auswahl 
an Farben. Mit diesen beiden Informationen, und dem Ausgangsgraphen, aus dem die Lösung berechnet wurde, ist eine Lösung eindeutig rekonstruierbar.
Umzu verhindern, dass die VNS-Schleife immer wieder auf die selben Lösungen kommt, ohne echte Verbesserungen zu erzielen, werden alle neuen, verbesserten
Lösungen komprimiert gespeichert. 

Zur komprimierten Speicherung wurde eine eigene Datenstruktur definiert, welche eben nur jene oben erwähnten Informationen abspeichert. 
Dazu werden zwei Arrays verwendet, welche einerseits die für einzelne Partitionen verwendeten Farben, andererseits aber auch die 
eindeutige Identifikationsnummern der Repräsentanten abspeichern. Um eine Solution einfach in solch eine StoredSolution umzuwandeln, wurde
ein Konstruktor definiert, welcher ein klassisches Solutionobjekt übernimmt. 

\singlespacing
\begin{lstlisting}[caption={Die Signatur von StoredSolution},label={lst:stored}]
struct StoredSolution {
   StoredSolution(Solution& toStore);
   ~StoredSolution();
   
   int n;
   
   int *colors;
   int *representatives;
   
   std::string toString();
};
\end{lstlisting}
\setstretch{1.5}

Für den schnelle Zuordnung einer neuen Lösung zu den bestehenden Lösungen wird eine Hashmap-Datenstruktur verwendet. Durch die Verwendung einer
Hashmap ist eine quasi sofortige Zuordnung einer Lösung zu dem entsprechenden Platz in der Hashmap möglich. Sollte eine Lösung schon einmal 
aufgekommen sein, wird dieser Lösungsstrang verworfen, da er nicht zu neuen Lösungen führen würde. Die Implementation der Hashmap wird von 
Boost, beschrieben im Abschnitt \ref{sec:boost}, bereitgestellt.

\subsection{Parser}
\label{sec:parser}


\subsection{Konstruktionsheuristik}

\subsection{Variable Nachbarschaftssuche}

\subsection{Nachbarschaften}



 
